"""
Query data models for Magpie.

These models define the structure of queries that flow into the pipeline.
"""

import datetime
import pydantic
import typing

class SubQuery(pydantic.BaseModel):
    """
    A single search query, potentially combining multiple concepts.
    
    Example: "computer vision explainability" combines two concepts
    to narrow the search to papers addressing both.

    TODO: Maybe? Consider adding boolean logic support for precision retrieval
          (query_type field, bool operators in text field, parsing in
          QueryProcessor)
    """
    text: str = pydantic.Field(
        ...,
        description="The search query text",
        min_length=1
    )
    
    weight: float = pydantic.Field(
        ...,
        description="Proportion of total results this query should retrieve (0-1)",
        ge=0.0,
        le=1.0
    )
    
    source_interest_ids: typing.Optional[typing.List[str]] = pydantic.Field(
        default=None,
        description="IDs of user interests that generated this subquery"
    )
    
    @pydantic.field_validator('text')
    @classmethod
    def text_not_empty(cls, v: str) -> str:
        """Ensure query text is not just whitespace."""
        if not v.strip():
            raise ValueError("Query text cannot be empty or whitespace")
        return v.strip()


class Query(pydantic.BaseModel):
    """
    Complete query specification for paper search.
    
    Contains multiple subqueries and search parameters.
    Gets generated by InputParserManager and flows through the pipeline.
    """
    queries: typing.List[SubQuery] = pydantic.Field(
        ...,
        description="typing.List of subqueries to execute independently",
        min_length=1
    )
    
    max_results: int = pydantic.Field(
        default=10,
        description="Total number of papers to return after merging all subqueries",
        ge=1,
        le=100
    )
    
    date_range: typing.Optional[typing.Tuple[datetime.date, datetime.date]] = pydantic.Field(
        default=None,
        description="Filter papers by publication date (start_date, end_date)"
    )
    
    min_citations: typing.Optional[int] = pydantic.Field(
        default=None,
        description="Minimum citation count for papers",
        ge=0
    )
    
    recency_weight: float = pydantic.Field(
        default=0.5,
        description="Weight for recent papers vs highly-cited papers (0=citations only, 1=recency only)",
        ge=0.0,
        le=1.0
    )
    
    venues: typing.Optional[typing.List[str]] = pydantic.Field(
        default=None,
        description="Preferred publication venues (conferences, journals)"
    )
    
    exclude_seen_papers: bool = pydantic.Field(
        default=True,
        description="Whether to filter out papers the user has already seen"
    )
    
    timestamp: datetime.datetime = pydantic.Field(
        default_factory=datetime.datetime.now,
        description="When this query was created"
    )
    
    user_id: typing.Optional[str] = pydantic.Field(
        default=None,
        description="ID of the user making this query (for multi-user support)"
    )
    
    original_input: typing.Optional[str] = pydantic.Field(
        default=None,
        description="The raw user input that generated this query (for debugging)"
    )
    
    @pydantic.field_validator('queries')
    @classmethod
    def weights_sum_to_one(cls, v: typing.List[SubQuery]) -> typing.List[SubQuery]:
        """Ensure subquery weights sum to approximately 1.0."""
        total_weight = sum(sq.weight for sq in v)
        if not (0.99 <= total_weight <= 1.01):  # Allow small floating point errors
            raise ValueError(f"Subquery weights must sum to 1.0, got {total_weight}")
        return v
    
    @pydantic.field_validator('date_range')
    @classmethod
    def validate_date_range(cls, v: typing.Optional[typing.Tuple[datetime.date, datetime.date]]) -> typing.Optional[typing.Tuple[datetime.date, datetime.date]]:
        """Ensure start date is before end date."""
        if v is not None:
            start_date, end_date = v
            if start_date > end_date:
                raise ValueError(f"Start date {start_date} must be before end date {end_date}")
        return v
    
    class Config:
        """Pydantic configuration."""
        # Allows validation with typing and datetime objects
        arbitrary_types_allowed = True
        # Example schema for the docs
        json_schema_extra = {
            "example": {
                "queries": [
                    {
                        "text": "computer vision explainability",
                        "weight": 0.6,
                        "source_interest_ids": ["interest-uuid-1", "interest-uuid-2"]
                    },
                    {
                        "text": "fine-grained image classification",
                        "weight": 0.4,
                        "source_interest_ids": ["interest-uuid-3"]
                    }
                ],
                "max_results": 20,
                "date_range": ["2023-01-01", "2025-01-20"],
                "min_citations": 10,
                "recency_weight": 0.7,
                "venues": ["CVPR", "ICCV", "NeurIPS"],
                "exclude_seen_papers": True,
                "original_input": "Find me recent papers on XAI in computer vision and fine-grained classification"
            }
        }
